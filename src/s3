import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
import { Upload } from '@aws-sdk/lib-storage';
import unzipper from 'unzipper';
import pLimit from 'p-limit';
import path from 'path';

const APP = {
  UNZIPPER_TYPES: { FILE: 'File' },
  EXTENSION: { O: '.o', I: '.i', AFP: '.afp' },
  S3_FOLDER: { INPROCESS: 'inprocess' },
  ERROR_TYPE: { UNZIP_UPLOAD: 'UNZIP_UPLOAD' }
};

const CHUNK_SIZE_MB = 15;
const CONCURRENCY_LIMIT = 25;

const s3 = new S3Client({ region: 'your-region' });

export async function unzipAndUploadFilesToS3(
  Bucket: string,
  s3ObjectStream: NodeJS.ReadableStream,
  batchName: string
): Promise<string[]> {
  const fileList: string[] = [];
  const limit = pLimit(CONCURRENCY_LIMIT);
  const uploadTasks: Promise<void>[] = [];

  const zipStream = s3ObjectStream.pipe(unzipper.Parse({ forceStream: true }));

  for await (const fileEntry of zipStream) {
    if (fileEntry.type !== APP.UNZIPPER_TYPES.FILE) {
      fileEntry.autodrain();
      continue;
    }

    let nameOfFile = path.basename(fileEntry.path).toLowerCase();

    // Adjust extension if needed
    if (!nameOfFile.endsWith(APP.EXTENSION.O) &&
        !nameOfFile.endsWith(APP.EXTENSION.I) &&
        !nameOfFile.endsWith(APP.EXTENSION.AFP)) {
      nameOfFile = nameOfFile.slice(0, -2) + APP.EXTENSION.AFP;
    }

    const fileBufferChunks: Uint8Array[] = [];
    let totalSize = 0;

    for await (const chunk of fileEntry) {
      fileBufferChunks.push(chunk);
      totalSize += chunk.length;
    }

    const fileBuffer = Buffer.concat(fileBufferChunks);
    const useManagedUpload = totalSize > CHUNK_SIZE_MB * 1024 * 1024;

    const key = `${batchName}/${APP.S3_FOLDER.INPROCESS}/${nameOfFile}`;

    const uploadPromise = limit(async () => {
      const start = Date.now();

      if (useManagedUpload) {
        await new Upload({
          client: s3,
          params: { Bucket, Key: key, Body: fileBuffer }
        }).done();
      } else {
        await s3.send(new PutObjectCommand({
          Bucket,
          Key: key,
          Body: fileBuffer
        }));
      }

      const end = Date.now();
      console.log(`Uploaded ${nameOfFile} (${(totalSize / 1024 / 1024).toFixed(2)} MB) in ${(end - start) / 1000}s`);

      fileList.push(key);
    });

    uploadTasks.push(uploadPromise);
  }

  const results = await Promise.allSettled(uploadTasks);

  results.forEach((result) => {
    if (result.status === 'rejected') {
      throw new Error(`${APP.ERROR_TYPE.UNZIP_UPLOAD}: ${result.reason?.message ?? 'Unknown error'}`);
    }
  });

  return fileList;
}
