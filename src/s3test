import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import archiver from "archiver";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuration
const outputDir = path.join(__dirname, "output_zips");
const sizesInMB = [10, 100, 500, 1024, 2048, 5120, 8192, 10240]; // in MB
const maxFiles = 200;

if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir);

function getRandomBuffer(sizeInBytes) {
  return Buffer.alloc(sizeInBytes, Math.floor(Math.random() * 256));
}

function getRandomFileName(index) {
  const ext = Math.random() > 0.5 ? "txt" : "pdf";
  return `file_${index}.${ext}`;
}

async function createZip(targetSizeMB) {
  const zipName = `zip_${targetSizeMB}MB.zip`;
  const zipPath = path.join(outputDir, zipName);
  const output = fs.createWriteStream(zipPath);
  const archive = archiver("zip", { zlib: { level: 1 } }); // Fastest compression

  return new Promise((resolve, reject) => {
    output.on("close", () => {
      console.log(`${zipName} created with size: ${(archive.pointer() / 1024 / 1024).toFixed(2)} MB`);
      resolve();
    });

    archive.on("error", err => reject(err));
    archive.pipe(output);

    const totalBytes = targetSizeMB * 1024 * 1024;
    const bytesPerFile = Math.floor(totalBytes / maxFiles);
    for (let i = 0; i < maxFiles; i++) {
      const fileName = getRandomFileName(i + 1);
      archive.append(getRandomBuffer(bytesPerFile), { name: fileName });
    }

    archive.finalize();
  });
}

async function main() {
  console.log("Generating test ZIPs...");
  for (const size of sizesInMB) {
    await createZip(size);
  }
  console.log("âœ… All ZIPs created in:", outputDir);
}

main().catch(err => console.error("Error:", err));
// npm install archiver
// node create-test-zips.js
